import PQueue from 'p-queue';
export interface CallLimits {
    timestamp: number;
    remaining: number;
    current: number;
    max: number;
    retryAfter: number | null;
}
declare class ApiInfo {
    accessToken: string;
    requestQueue: PQueue;
    constructor(accessToken: string);
    /**
     * As a reasonable default, assume the bucket is half full and the limit is 40.
     * This is updated after the first response from Shopify.
     */
    private _callLimits;
    /**
     * Sets the call-limits from the last Shopify response header x-shopify-shop-api-call-limit'.
     * This is a string of the form `${current}/${max}`, indicating how full the "leaky bucket" of requests already is.
     * In case of a 429 (too many requests) error, Shopify may additionally provide a 'retry-after' header, indicating
     * the number of seconds when the request should be retried.
     * This is all taken into account for timing the next API call.
     *
     * @param val string
     * @param timestamp number | null
     * @param retryAfter number | null
     * @returns CallLimits
     *
     * TODO: Certain endpoints have limits that differ from the normal bucket size. For example, order.create is limited
     * to 5 per minute for development stores. These individual limits should be added to the individual API service
     * classes where they apply.
     */
    setCallLimits(limits: string, retryAfter?: string | null, timestamp?: null | number): CallLimits;
    /**
     * Gets the current call limits, calculated from the last response by Shopify and the time passed since then.
     * Optional parameter `increaseCurrent` increments the stored bucket fill state pre-emptively. This is done before making a request,
     * so that the limit is already updated to the higher fill state before a response comes back.
     *
     * @param increaseCurrent number
     * @returns CallLimits
     */
    getCallLimits(increaseCurrent?: number): CallLimits;
}
export declare class BaseService {
    private shopDomain;
    private accessToken;
    private resource;
    private static _apiInfo;
    apiInfo: {
        [key: string]: ApiInfo;
    };
    constructor(shopDomain: string, accessToken: string, resource: string);
    getCallLimits(increaseCurrent?: number): CallLimits;
    static buildDefaultHeaders(): {
        Accept: string;
        'User-Agent': string;
    };
    /**
     * Joins URI paths into one single string, replacing bad slashes and ensuring the path doesn't end in /.json.
     */
    protected joinUriPaths(...paths: string[]): string;
    protected createRequest<T>(method: 'DELETE', path: string, rootElement?: string, payload?: any): Promise<undefined>;
    protected createRequest<T>(method: 'GET' | 'POST' | 'PUT', path: string, rootElement?: string, payload?: any): Promise<T>;
}
export default BaseService;
