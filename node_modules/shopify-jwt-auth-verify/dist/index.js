"use strict";
exports.__esModule = true;
// Node crypto & bufferFrom
var buffer_1 = require("buffer");
var url_1 = require("url");
var crypto = require("crypto");
// Utils
var atob = function (a) {
    if (a === void 0) { a = ''; }
    return buffer_1.Buffer.from(a, 'base64').toString('binary');
};
var base64UrlEncode = function (buffer) { return buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, ''); };
// is Verified and not expired
var isVerified = function (authorization, secret, key, cb, returnCallback) {
    // Early return for missing params
    if (!authorization || !secret || !key) {
        console.error('authorization or app secret or app key missing');
        return false;
    }
    // probably could be cleaned up this is dirty, straight string replace to remove the stragglers and split it. 
    var auth = authorization.replace('Bearer ', '').split('.');
    // will be passed to the optional call back
    var authObject = {
        header: atob(auth[0]),
        payload: atob(auth[1]),
        signature: auth[2]
    };
    var headerPayload = [auth[0], auth[1]].join('.');
    var signedBuffer = crypto.createHmac('sha256', secret).update(headerPayload).digest();
    var isVerified = authObject.signature === base64UrlEncode(signedBuffer);
    if (!isVerified) {
        console.error('Token is invalid');
        return false;
    }
    // validate not expired
    var payload = JSON.parse(authObject.payload);
    var time = new Date().getTime() / 1000;
    var isExpired = payload.exp <= time;
    var isValidAfter = payload.nbf <= time;
    var iss = new url_1.URL(payload.iss).hostname;
    var dest = new url_1.URL(payload.dest).hostname;
    // still valid
    if (isExpired) {
        console.error('Token is expired');
        return false;
    }
    // valid from
    if (!isValidAfter) {
        console.error('Token is not yet valid');
        return false;
    }
    if (iss != dest) {
        console.error("Token issuer " + iss + " does not match the destination " + dest);
        return false;
    }
    if (payload.aud != key) {
        console.error('Token does not match the Shopify API Key');
        return false;
    }
    // call the optional callback with the authObject
    if (cb && !returnCallback) {
        // in chain call back, 
        cb(authObject, payload);
    }
    // return valid or a callback if specified by returnCallback
    return !returnCallback ? true : cb(authObject, payload);
};
exports["default"] = isVerified;
//# sourceMappingURL=index.js.map